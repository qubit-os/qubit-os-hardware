// Copyright 2026 QubitOS Contributors
// SPDX-License-Identifier: Apache-2.0

//! Golden file cross-validation: Rust Lindblad solver vs QuTiP mesolve().
//!
//! Reference density matrices were generated by QuTiP 5.2.3 (mesolve) and
//! saved to `tests/golden_lindblad_qutip.json`. This test verifies that our
//! RK4 Lindblad solver matches within trace distance < 0.01.
//!
//! To regenerate the golden file, run:
//!   cd ../qubit-os-core && source .venv/bin/activate
//!   python3 scripts/generate_lindblad_golden.py > ../qubit-os-hardware/tests/golden_lindblad_qutip.json
//!
//! Ref: Johansson et al. (2012), Comp. Phys. Comm. 183, 1760.
//!   DOI: 10.1016/j.cpc.2012.02.021

use ndarray::Array2;
use num_complex::Complex64;

use qubit_os_hardware::lindblad::{
    solve_lindblad, state_fidelity, trace_distance, CollapseOperator, LindbladConfig,
};

#[derive(Debug, serde::Deserialize)]
struct GoldenCase {
    label: String,
    t1_us: f64,
    t2_us: f64,
    duration_ns: f64,
    n_steps: usize,
    rho_flat: Vec<f64>,
}

fn load_golden_cases() -> Vec<GoldenCase> {
    let json_str = include_str!("golden_lindblad_qutip.json");
    serde_json::from_str(json_str).expect("Failed to parse golden Lindblad JSON")
}

fn flat_to_density_matrix(flat: &[f64]) -> Array2<Complex64> {
    assert_eq!(flat.len(), 8, "Expected 2×2 density matrix (8 floats)");
    let mut rho = Array2::zeros((2, 2));
    rho[[0, 0]] = Complex64::new(flat[0], flat[1]);
    rho[[0, 1]] = Complex64::new(flat[2], flat[3]);
    rho[[1, 0]] = Complex64::new(flat[4], flat[5]);
    rho[[1, 1]] = Complex64::new(flat[6], flat[7]);
    rho
}

fn initial_state_for(label: &str) -> Array2<Complex64> {
    match label {
        "excited_t1_decay" | "t1_limited" | "short_gate_mild_decay" => {
            // |1⟩⟨1|
            let mut rho = Array2::zeros((2, 2));
            rho[[1, 1]] = Complex64::new(1.0, 0.0);
            rho
        }
        "plus_dephasing" => {
            // |+⟩⟨+| = ½(I + σx)
            let h = Complex64::new(0.5, 0.0);
            let mut rho = Array2::zeros((2, 2));
            rho[[0, 0]] = h;
            rho[[0, 1]] = h;
            rho[[1, 0]] = h;
            rho[[1, 1]] = h;
            rho
        }
        _ => panic!("Unknown test case: {label}"),
    }
}

#[test]
fn golden_lindblad_vs_qutip() {
    let cases = load_golden_cases();
    assert!(!cases.is_empty(), "No golden cases loaded");

    let mut all_pass = true;

    for case in &cases {
        eprintln!("\n=== {} ===", case.label);
        eprintln!(
            "  T1={:.0}μs, T2={:.0}μs, duration={:.0}ns, steps={}",
            case.t1_us, case.t2_us, case.duration_ns, case.n_steps
        );

        let qutip_rho = flat_to_density_matrix(&case.rho_flat);
        let initial = initial_state_for(&case.label);

        // Build Rust solver
        let ops = CollapseOperator::from_t1_t2(case.t1_us, case.t2_us, "q0").unwrap();
        let h_zero = Array2::zeros((2, 2));
        let hamiltonians: Vec<_> = (0..case.n_steps).map(|_| h_zero.clone()).collect();

        let config = LindbladConfig {
            num_time_steps: case.n_steps,
            duration_ns: case.duration_ns,
            collapse_ops: ops,
            store_trajectory: false,
        };

        let result = solve_lindblad(&initial, &hamiltonians, &config).unwrap();
        let rust_rho = &result.final_density_matrix;

        // Compute metrics
        let fid = state_fidelity(rust_rho, &qutip_rho);
        let td = trace_distance(rust_rho, &qutip_rho);

        eprintln!("  Fidelity(Rust, QuTiP): {:.8}", fid);
        eprintln!("  Trace distance:        {:.8}", td);
        eprintln!("  Rust purity:           {:.6}", result.final_purity);
        eprintln!("  Rust trace:            {:.8}", result.final_trace);

        // Print density matrices
        for (name, rho) in [("QuTiP", &qutip_rho), ("Rust ", rust_rho)] {
            eprintln!("  {name} ρ:");
            for i in 0..2 {
                eprint!("   ");
                for j in 0..2 {
                    let z = rho[[i, j]];
                    eprint!(" ({:+.8}, {:+.8}i)", z.re, z.im);
                }
                eprintln!();
            }
        }

        // Acceptance: trace distance < 0.01
        if td > 0.01 {
            eprintln!("  ❌ FAIL: trace distance {:.8} > 0.01", td);
            all_pass = false;
        } else {
            eprintln!("  ✅ PASS (trace distance {:.2e})", td);
        }
    }

    assert!(
        all_pass,
        "One or more Lindblad golden tests exceeded trace distance threshold of 0.01"
    );
}
