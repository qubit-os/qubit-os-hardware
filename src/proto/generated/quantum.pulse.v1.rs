// This file is @generated by prost-build.
/// HamiltonianSpec defines the system Hamiltonian for pulse optimization.
///
/// The Hamiltonian describes the quantum system's energy structure and is
/// essential for GRAPE optimization. QubitOS supports multiple representation
/// formats for flexibility.
///
/// Example (Pauli string for transmon):
///    format: PAULI_STRING
///    content: "4.8734*Z0 - 0.1*Z0*Z0 + 5.1023*Z1 - 0.0975*Z1*Z1 + 0.025*Z0*Z1"
///    hilbert_space_dim: 4
///    num_qubits: 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HamiltonianSpec {
    /// The format of the content field.
    #[prost(enumeration = "hamiltonian_spec::RepresentationFormat", tag = "1")]
    pub format: i32,
    /// The Hamiltonian specification in the chosen format.
    /// For PAULI_STRING: the Pauli string expression.
    /// For MATRIX_SPARSE: JSON object with COO data.
    /// For MATRIX_DENSE: JSON array of complex numbers.
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// Dimension of the Hilbert space.
    /// Must equal 2^num_qubits for qubit systems.
    /// Example: 4 for 2 qubits, 8 for 3 qubits.
    #[prost(int32, tag = "3")]
    pub hilbert_space_dim: i32,
    /// Number of qubits in the system.
    #[prost(int32, tag = "4")]
    pub num_qubits: i32,
    /// Tolerance for Hermiticity validation.
    /// The Hamiltonian must satisfy: ||H - H^dag|| < validation_tolerance
    /// Default: 1e-10
    #[prost(double, tag = "5")]
    pub validation_tolerance: f64,
    /// Control Hamiltonians for GRAPE optimization.
    /// These are the operators that get multiplied by the control amplitudes.
    /// Typically: \["X0", "Y0"\] for single-qubit or \["X0", "Y0", "X1", "Y1", "X0*X1"\] for two-qubit.
    #[prost(string, repeated, tag = "6")]
    pub control_operators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether this Hamiltonian has been validated.
    /// Set by the validation layer after checking Hermiticity and dimensions.
    #[prost(bool, tag = "7")]
    pub validated: bool,
    /// If validation failed, this contains the error message.
    #[prost(string, tag = "8")]
    pub validation_error: ::prost::alloc::string::String,
}
/// Nested message and enum types in `HamiltonianSpec`.
pub mod hamiltonian_spec {
    /// Representation format for the Hamiltonian.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RepresentationFormat {
        Unspecified = 0,
        /// Pauli string representation.
        /// Format: "coeff*P0*P1*... + coeff*P0*P1*..."
        /// where P is I, X, Y, or Z and the number is the qubit index.
        /// See docs/specs/pauli-string-grammar.md for full grammar.
        PauliString = 1,
        /// Sparse matrix in COO format (JSON).
        /// See docs/specs/matrix-formats.md for schema.
        MatrixSparse = 2,
        /// Dense matrix as row-major array of complex numbers (JSON).
        MatrixDense = 3,
    }
    impl RepresentationFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REPRESENTATION_FORMAT_UNSPECIFIED",
                Self::PauliString => "REPRESENTATION_FORMAT_PAULI_STRING",
                Self::MatrixSparse => "REPRESENTATION_FORMAT_MATRIX_SPARSE",
                Self::MatrixDense => "REPRESENTATION_FORMAT_MATRIX_DENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPRESENTATION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "REPRESENTATION_FORMAT_PAULI_STRING" => Some(Self::PauliString),
                "REPRESENTATION_FORMAT_MATRIX_SPARSE" => Some(Self::MatrixSparse),
                "REPRESENTATION_FORMAT_MATRIX_DENSE" => Some(Self::MatrixDense),
                _ => None,
            }
        }
    }
}
/// PulseShape defines a complete pulse waveform for quantum gate implementation.
///
/// The pulse consists of in-phase (I) and quadrature (Q) components,
/// discretized into time steps. For two-qubit gates, an optional coupling
/// envelope may also be specified.
///
/// Time structure:
///    - duration_ns: total pulse duration in nanoseconds
///    - num_time_steps: number of discrete time slices
///    - time_step_ns: duration of each slice (= duration_ns / num_time_steps)
///    - i_envelope, q_envelope: amplitude at each time step
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PulseShape {
    /// Unique identifier for this pulse (UUID format).
    #[prost(string, tag = "1")]
    pub pulse_id: ::prost::alloc::string::String,
    /// Algorithm used to generate this pulse.
    /// Values: "grape", "drag", "gaussian", "square", "custom"
    #[prost(string, tag = "2")]
    pub algorithm: ::prost::alloc::string::String,
    /// Target gate type.
    #[prost(enumeration = "GateType", tag = "3")]
    pub gate_type: i32,
    /// Indices of qubits this pulse acts on.
    /// Single-qubit gates: \[0\] or \[1\]
    /// Two-qubit gates: \[0, 1\] (control, target for CNOT)
    #[prost(int32, repeated, tag = "4")]
    pub target_qubit_indices: ::prost::alloc::vec::Vec<i32>,
    /// Target fidelity used during optimization.
    /// Range: (0, 1], typically >= 0.99
    #[prost(double, tag = "5")]
    pub target_fidelity: f64,
    /// Total pulse duration in nanoseconds.
    /// Typical range: 10-1000 ns
    /// Limit: 100,000 ns (100 μs, enforced by server)
    #[prost(int32, tag = "6")]
    pub duration_ns: i32,
    /// Number of discrete time steps.
    /// Higher values = finer control but longer optimization.
    /// Typical range: 20-500
    /// Limit: 10,000 (enforced by server)
    #[prost(int32, tag = "7")]
    pub num_time_steps: i32,
    /// Duration of each time step in nanoseconds.
    /// Computed as: duration_ns / num_time_steps
    /// Included for convenience and validation.
    #[prost(double, tag = "8")]
    pub time_step_ns: f64,
    /// In-phase (I) component of the pulse envelope.
    /// Length must equal num_time_steps.
    /// Units: MHz (drive amplitude)
    /// Limit: 10,000 elements max (enforced by server)
    /// Values must be finite and within ±1000 MHz
    #[prost(double, repeated, tag = "9")]
    pub i_envelope: ::prost::alloc::vec::Vec<f64>,
    /// Quadrature (Q) component of the pulse envelope.
    /// Length must equal num_time_steps.
    /// Units: MHz (drive amplitude)
    /// Limit: 10,000 elements max (enforced by server)
    /// Values must be finite and within ±1000 MHz
    #[prost(double, repeated, tag = "10")]
    pub q_envelope: ::prost::alloc::vec::Vec<f64>,
    /// Maximum amplitude bound in MHz.
    /// All envelope values must satisfy |value| <= max_amplitude_mhz.
    #[prost(double, tag = "11")]
    pub max_amplitude_mhz: f64,
    /// Coupling envelope for two-qubit gates (optional).
    /// Used for tunable coupler control or cross-resonance drives.
    /// Length must equal num_time_steps if present.
    #[prost(double, repeated, tag = "12")]
    pub coupling_envelope: ::prost::alloc::vec::Vec<f64>,
    /// For rotation gates (RX, RY, RZ): the rotation angle in radians.
    #[prost(double, tag = "13")]
    pub rotation_angle: f64,
    /// Whether this pulse has been validated.
    #[prost(bool, tag = "14")]
    pub validated: bool,
    /// If validation failed, this contains the error message.
    #[prost(string, tag = "15")]
    pub validation_error: ::prost::alloc::string::String,
    /// Protocol buffer version for this message.
    #[prost(int32, tag = "16")]
    pub proto_version: i32,
    /// When this pulse was created.
    #[prost(message, optional, tag = "17")]
    pub created_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// Fingerprint of the calibration used during optimization.
    /// Format: "sha256:<16 hex chars>"
    #[prost(string, tag = "18")]
    pub calibration_fingerprint: ::prost::alloc::string::String,
    /// Version of the code that generated this pulse.
    /// Git SHA or semantic version.
    #[prost(string, tag = "19")]
    pub code_version: ::prost::alloc::string::String,
    /// Random seed used during optimization.
    /// Enables reproducibility: same seed + code + calibration = identical pulse.
    #[prost(int32, tag = "20")]
    pub random_seed: i32,
    /// For GATE_CUSTOM: JSON representation of the target unitary matrix.
    /// Format: {"rows": N, "cols": N, "data": \[[re, im\], ...]}
    #[prost(string, tag = "21")]
    pub custom_unitary_json: ::prost::alloc::string::String,
}
/// PulseLibraryEntry represents a named pulse in a library.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PulseLibraryEntry {
    /// Human-readable name for this pulse.
    /// Example: "x_gate_20ns_q0"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional description.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The pulse shape.
    #[prost(message, optional, tag = "3")]
    pub pulse: ::core::option::Option<PulseShape>,
    /// Tags for organization.
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// PulseLibrary is a collection of named pulses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PulseLibrary {
    /// Version of the library format.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// When this library was created/updated.
    #[prost(message, optional, tag = "2")]
    pub updated_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// The pulses in this library.
    #[prost(message, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<PulseLibraryEntry>,
}
/// GateType enumerates supported quantum gates.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GateType {
    Unspecified = 0,
    /// Single-qubit gates
    ///
    /// Pauli-X (NOT gate)
    X = 1,
    /// Pauli-Y
    Y = 2,
    /// Pauli-Z
    Z = 3,
    /// sqrt(X), a.k.a. sqrt(NOT)
    Sx = 4,
    /// Hadamard
    H = 5,
    /// Rotation around X-axis
    Rx = 6,
    /// Rotation around Y-axis
    Ry = 7,
    /// Rotation around Z-axis (virtual Z, typically no pulse needed)
    Rz = 8,
    /// S gate (sqrt(Z))
    S = 9,
    /// T gate (fourth root of Z)
    T = 10,
    /// Two-qubit gates
    ///
    /// Controlled-Z
    Cz = 20,
    /// Controlled-NOT (CX)
    Cnot = 21,
    /// iSWAP
    Iswap = 22,
    /// sqrt(iSWAP)
    Sqiswap = 23,
    /// Alias for CNOT
    Cx = 24,
    /// SWAP gate
    Swap = 25,
    /// Custom gate (specify unitary in metadata)
    Custom = 99,
}
impl GateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GATE_TYPE_UNSPECIFIED",
            Self::X => "GATE_TYPE_X",
            Self::Y => "GATE_TYPE_Y",
            Self::Z => "GATE_TYPE_Z",
            Self::Sx => "GATE_TYPE_SX",
            Self::H => "GATE_TYPE_H",
            Self::Rx => "GATE_TYPE_RX",
            Self::Ry => "GATE_TYPE_RY",
            Self::Rz => "GATE_TYPE_RZ",
            Self::S => "GATE_TYPE_S",
            Self::T => "GATE_TYPE_T",
            Self::Cz => "GATE_TYPE_CZ",
            Self::Cnot => "GATE_TYPE_CNOT",
            Self::Iswap => "GATE_TYPE_ISWAP",
            Self::Sqiswap => "GATE_TYPE_SQISWAP",
            Self::Cx => "GATE_TYPE_CX",
            Self::Swap => "GATE_TYPE_SWAP",
            Self::Custom => "GATE_TYPE_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "GATE_TYPE_X" => Some(Self::X),
            "GATE_TYPE_Y" => Some(Self::Y),
            "GATE_TYPE_Z" => Some(Self::Z),
            "GATE_TYPE_SX" => Some(Self::Sx),
            "GATE_TYPE_H" => Some(Self::H),
            "GATE_TYPE_RX" => Some(Self::Rx),
            "GATE_TYPE_RY" => Some(Self::Ry),
            "GATE_TYPE_RZ" => Some(Self::Rz),
            "GATE_TYPE_S" => Some(Self::S),
            "GATE_TYPE_T" => Some(Self::T),
            "GATE_TYPE_CZ" => Some(Self::Cz),
            "GATE_TYPE_CNOT" => Some(Self::Cnot),
            "GATE_TYPE_ISWAP" => Some(Self::Iswap),
            "GATE_TYPE_SQISWAP" => Some(Self::Sqiswap),
            "GATE_TYPE_CX" => Some(Self::Cx),
            "GATE_TYPE_SWAP" => Some(Self::Swap),
            "GATE_TYPE_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// OptimizeRequest initiates a GRAPE (Gradient Ascent Pulse Engineering) optimization.
///
/// GRAPE finds optimal control pulses by iteratively improving an initial guess
/// using gradient information. The optimization maximizes gate fidelity while
/// respecting amplitude and bandwidth constraints.
///
/// Typical workflow:
/// 1. Define system Hamiltonian and control operators
/// 2. Specify target gate and fidelity threshold
/// 3. Set time discretization (duration, steps)
/// 4. Configure optimizer (learning rate, regularization)
/// 5. Run optimization and receive optimized pulse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptimizeRequest {
    /// Trace context for distributed tracing.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// System (drift) Hamiltonian.
    /// This describes the time-independent part of the Hamiltonian.
    #[prost(message, optional, tag = "2")]
    pub system_hamiltonian: ::core::option::Option<HamiltonianSpec>,
    /// Target gate to implement.
    #[prost(enumeration = "GateType", tag = "3")]
    pub target_gate: i32,
    /// Qubit indices the gate acts on.
    #[prost(int32, repeated, tag = "4")]
    pub target_qubit_indices: ::prost::alloc::vec::Vec<i32>,
    /// For rotation gates: the rotation angle in radians.
    #[prost(double, tag = "5")]
    pub rotation_angle: f64,
    /// For custom gates: the target unitary as JSON.
    #[prost(string, tag = "6")]
    pub custom_unitary_json: ::prost::alloc::string::String,
    /// Target gate fidelity.
    /// Optimization stops when this fidelity is reached.
    /// Typical: 0.999 for single-qubit, 0.99 for two-qubit.
    #[prost(double, tag = "7")]
    pub target_fidelity: f64,
    /// Maximum number of iterations.
    /// Optimization stops if target fidelity not reached within this limit.
    /// Typical: 500-5000
    #[prost(int32, tag = "8")]
    pub max_iterations: i32,
    /// Number of time steps for pulse discretization.
    /// More steps = finer control but longer optimization.
    /// Typical: 50-200
    #[prost(int32, tag = "9")]
    pub num_time_steps: i32,
    /// Total pulse duration in nanoseconds.
    /// Typical: 20-100 ns for single-qubit, 40-200 ns for two-qubit.
    #[prost(int32, tag = "10")]
    pub duration_ns: i32,
    /// Initial learning rate.
    /// Typical: 0.01-0.1 for Adam, 1.0 for L-BFGS
    #[prost(double, tag = "11")]
    pub learning_rate: f64,
    /// Random seed for reproducibility.
    /// Same seed + same inputs = identical output.
    #[prost(int32, tag = "12")]
    pub random_seed: i32,
    /// Advanced optimizer options.
    #[prost(message, optional, tag = "13")]
    pub options: ::core::option::Option<GrapeOptions>,
    /// Maximum pulse amplitude in MHz.
    /// All control values will be bounded by this.
    /// Typical: 50-200 MHz
    #[prost(double, tag = "14")]
    pub max_amplitude_mhz: f64,
    /// Request timeout in milliseconds.
    /// 0 = use server default (typically 5 minutes).
    #[prost(int32, tag = "15")]
    pub timeout_ms: i32,
    /// Required calibration fingerprint.
    /// If specified, optimization uses this calibration's noise parameters.
    #[prost(string, tag = "16")]
    pub calibration_fingerprint: ::prost::alloc::string::String,
}
/// GRAPEOptions contains advanced optimizer configuration.
///
/// --- Optimizer Selection ---
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrapeOptions {
    /// Optimizer algorithm.
    /// Values: "adam" (default), "lbfgs", "sgd", "rmsprop"
    #[prost(string, tag = "1")]
    pub optimizer: ::prost::alloc::string::String,
    /// Memory size for L-BFGS optimizer.
    /// Only used when optimizer = "lbfgs".
    /// Default: 10
    #[prost(int32, tag = "2")]
    pub lbfgs_memory: i32,
    /// Learning rate decay factor.
    /// Applied every decay_interval iterations.
    /// Example: 0.95 means lr = lr * 0.95 every decay_interval steps.
    /// Default: 1.0 (no decay)
    #[prost(double, tag = "3")]
    pub learning_rate_decay: f64,
    /// Iterations between learning rate decay steps.
    /// Default: 50
    #[prost(int32, tag = "4")]
    pub decay_interval: i32,
    /// L2 penalty on control amplitudes.
    /// Encourages smaller pulse amplitudes.
    /// Default: 0.0
    #[prost(double, tag = "5")]
    pub l2_amplitude_penalty: f64,
    /// Smoothness penalty (penalizes rapid amplitude changes).
    /// Encourages bandwidth-limited pulses.
    /// Default: 0.0
    #[prost(double, tag = "6")]
    pub smoothness_penalty: f64,
    /// Hard bandwidth limit in MHz.
    /// Pulses are filtered to remove components above this frequency.
    /// 0 = no filtering.
    /// Default: 0
    #[prost(double, tag = "7")]
    pub bandwidth_limit_mhz: f64,
    /// Fidelity improvement threshold for convergence.
    /// Optimization is "stalled" if improvement over convergence_window
    /// iterations is less than this value.
    /// Default: 1e-8
    #[prost(double, tag = "8")]
    pub convergence_threshold: f64,
    /// Number of iterations to check for convergence.
    /// Default: 10
    #[prost(int32, tag = "9")]
    pub convergence_window: i32,
    /// Maximum gradient norm (for gradient clipping).
    /// Prevents divergence on stiff optimization problems.
    /// Default: 1.0
    #[prost(double, tag = "10")]
    pub gradient_clip_norm: f64,
    /// Pulse ID to use as initial guess (optional).
    /// If empty, starts from random or standard initial guess.
    #[prost(string, tag = "11")]
    pub initial_pulse_id: ::prost::alloc::string::String,
    /// Type of initial guess if not using existing pulse.
    /// Values: "random", "gaussian", "zeros"
    /// Default: "random"
    #[prost(string, tag = "12")]
    pub initial_guess_type: ::prost::alloc::string::String,
    /// Include T1/T2 decoherence in optimization.
    /// Uses values from calibration.
    /// Default: false
    #[prost(bool, tag = "13")]
    pub include_decoherence: bool,
    /// Include leakage to non-computational states.
    /// Requires anharmonicity in calibration.
    /// Default: false
    #[prost(bool, tag = "14")]
    pub include_leakage: bool,
    /// Number of transmon levels to include (for leakage modeling).
    /// Default: 3
    #[prost(int32, tag = "15")]
    pub transmon_levels: i32,
}
/// OptimizeResponse contains the result of a GRAPE optimization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptimizeResponse {
    /// Trace context echoed back.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// Whether optimization succeeded.
    #[prost(bool, tag = "2")]
    pub success: bool,
    /// Error details if success = false.
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::Error>,
    /// The optimized pulse.
    #[prost(message, optional, tag = "4")]
    pub optimized_pulse: ::core::option::Option<PulseShape>,
    /// Achieved gate fidelity.
    #[prost(double, tag = "5")]
    pub achieved_fidelity: f64,
    /// Number of iterations actually used.
    #[prost(int32, tag = "6")]
    pub iterations_used: i32,
    /// Why optimization stopped.
    /// Values: "target_reached", "max_iterations", "stalled", "timeout", "cancelled", "error"
    #[prost(string, tag = "7")]
    pub convergence_reason: ::prost::alloc::string::String,
    /// Fidelity at each iteration.
    /// Length = iterations_used + 1 (includes initial fidelity).
    #[prost(double, repeated, tag = "8")]
    pub fidelity_history: ::prost::alloc::vec::Vec<f64>,
    /// Gradient norm at each iteration.
    /// Useful for debugging convergence issues.
    #[prost(double, repeated, tag = "9")]
    pub gradient_norms: ::prost::alloc::vec::Vec<f64>,
    /// Final regularization cost (if regularization was used).
    #[prost(double, tag = "10")]
    pub final_regularization_cost: f64,
    /// Wall-clock time for optimization in milliseconds.
    #[prost(int64, tag = "11")]
    pub wall_time_ms: i64,
    /// Non-fatal warnings generated during optimization.
    /// Example: "Gradient clipping applied 15 times"
    #[prost(string, repeated, tag = "12")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// CancelRequest requests cancellation of a running optimization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRequest {
    /// Trace ID of the optimization to cancel.
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
}
/// CancelResponse confirms cancellation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelResponse {
    /// Whether cancellation was successful.
    /// May be false if optimization already completed.
    #[prost(bool, tag = "1")]
    pub cancelled: bool,
    /// Partial result if available.
    /// Contains best pulse found before cancellation.
    #[prost(message, optional, tag = "2")]
    pub partial_result: ::core::option::Option<OptimizeResponse>,
}
/// Generated client implementations.
pub mod grape_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// GRAPE service definition.
    #[derive(Debug, Clone)]
    pub struct GrapeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GrapeServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GrapeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GrapeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GrapeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Run GRAPE optimization.
        pub async fn optimize(
            &mut self,
            request: impl tonic::IntoRequest<super::OptimizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OptimizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.pulse.v1.GRAPEService/Optimize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("quantum.pulse.v1.GRAPEService", "Optimize"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a running optimization.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelRequest>,
        ) -> std::result::Result<tonic::Response<super::CancelResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.pulse.v1.GRAPEService/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("quantum.pulse.v1.GRAPEService", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod grape_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GrapeServiceServer.
    #[async_trait]
    pub trait GrapeService: std::marker::Send + std::marker::Sync + 'static {
        /// Run GRAPE optimization.
        async fn optimize(
            &self,
            request: tonic::Request<super::OptimizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OptimizeResponse>,
            tonic::Status,
        >;
        /// Cancel a running optimization.
        async fn cancel(
            &self,
            request: tonic::Request<super::CancelRequest>,
        ) -> std::result::Result<tonic::Response<super::CancelResponse>, tonic::Status>;
    }
    /// GRAPE service definition.
    #[derive(Debug)]
    pub struct GrapeServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GrapeServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GrapeServiceServer<T>
    where
        T: GrapeService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/quantum.pulse.v1.GRAPEService/Optimize" => {
                    #[allow(non_camel_case_types)]
                    struct OptimizeSvc<T: GrapeService>(pub Arc<T>);
                    impl<
                        T: GrapeService,
                    > tonic::server::UnaryService<super::OptimizeRequest>
                    for OptimizeSvc<T> {
                        type Response = super::OptimizeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OptimizeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GrapeService>::optimize(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OptimizeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/quantum.pulse.v1.GRAPEService/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: GrapeService>(pub Arc<T>);
                    impl<
                        T: GrapeService,
                    > tonic::server::UnaryService<super::CancelRequest>
                    for CancelSvc<T> {
                        type Response = super::CancelResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CancelRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GrapeService>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for GrapeServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "quantum.pulse.v1.GRAPEService";
    impl<T> tonic::server::NamedService for GrapeServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
