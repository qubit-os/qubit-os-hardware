// This file is @generated by prost-build.
/// A single error contribution to the budget.
///
/// Immutable record of one error event (e.g., one gate on one qubit).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorContribution {
    /// Which error mechanism produced this contribution.
    #[prost(enumeration = "ErrorSource", tag = "1")]
    pub source: i32,
    /// Error magnitude. For gates: 1 - fidelity. Must be >= 0.
    #[prost(double, tag = "2")]
    pub infidelity: f64,
    /// Which qubit this error acts on.
    #[prost(int32, tag = "3")]
    pub qubit: i32,
    /// Duration of this operation in nanoseconds. 0 for instantaneous
    /// operations (e.g., readout classification).
    #[prost(double, tag = "4")]
    pub duration_ns: f64,
    /// Human-readable label (e.g., "X gate on q0").
    #[prost(string, tag = "5")]
    pub label: ::prost::alloc::string::String,
}
/// Error budget summary for a pulse sequence.
///
/// Contains the projected fidelity, breakdown by source, and per-qubit
/// time accounting. Suitable for inclusion in MeasurementResult as a
/// pre-execution prediction.
///
/// --- Target and projections ---
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorBudgetSummary {
    /// Target sequence fidelity (e.g., 0.99).
    #[prost(double, tag = "1")]
    pub target_fidelity: f64,
    /// Predicted fidelity: max(0, 1 - projected_infidelity).
    #[prost(double, tag = "2")]
    pub projected_fidelity: f64,
    /// Total projected infidelity from all sources.
    #[prost(double, tag = "3")]
    pub projected_infidelity: f64,
    /// Error budget remaining: max(0, (1 - target_fidelity) - projected_infidelity).
    #[prost(double, tag = "4")]
    pub remaining_budget: f64,
    /// Whether the sequence meets the target fidelity.
    #[prost(bool, tag = "5")]
    pub is_within_budget: bool,
    /// Number of operations (gates + idles + readouts) in the sequence.
    #[prost(int32, tag = "6")]
    pub num_operations: i32,
    /// The error source contributing the most infidelity.
    #[prost(enumeration = "ErrorSource", tag = "7")]
    pub dominant_source: i32,
    /// Sum of gate infidelities (stochastic component).
    #[prost(double, tag = "10")]
    pub gate_infidelity: f64,
    /// Coherent noise correction: kappa * (sum(sqrt(epsilon_i)))^2.
    #[prost(double, tag = "11")]
    pub coherent_correction: f64,
    /// Total decoherence error from T1/T2 decay.
    #[prost(double, tag = "12")]
    pub decoherence: f64,
    /// Total readout error.
    #[prost(double, tag = "13")]
    pub readout_error: f64,
    /// Total crosstalk error.
    #[prost(double, tag = "14")]
    pub crosstalk_error: f64,
    /// Total leakage error.
    #[prost(double, tag = "15")]
    pub leakage_error: f64,
    /// Accumulated time per qubit in nanoseconds.
    /// Key: qubit index, Value: total time (gate + idle) on that qubit.
    #[prost(map = "int32, double", tag = "20")]
    pub per_qubit_time_ns: ::std::collections::HashMap<i32, f64>,
    /// All individual contributions (optional, may be large for long sequences).
    #[prost(message, repeated, tag = "21")]
    pub contributions: ::prost::alloc::vec::Vec<ErrorContribution>,
}
/// Sequence analysis with quality grade and recommendations.
///
/// Wraps an ErrorBudgetSummary with human-readable guidance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceAnalysis {
    /// The error budget summary.
    #[prost(message, optional, tag = "1")]
    pub budget: ::core::option::Option<ErrorBudgetSummary>,
    /// Quality grade: "A" (F >= 0.999), "B" (>= 0.99), "C" (>= 0.95),
    /// "D" (>= 0.90), "F" (< 0.90).
    #[prost(string, tag = "2")]
    pub grade: ::prost::alloc::string::String,
    /// Actionable recommendations based on dominant error source.
    #[prost(string, repeated, tag = "3")]
    pub recommendations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Warnings about budget exhaustion or physics issues.
    #[prost(string, repeated, tag = "4")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Classification of error sources.
///
/// Each source corresponds to a distinct physical mechanism.
/// See ERROR-BUDGET-SPEC.md ยง5.1 for formulas.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorSource {
    Unspecified = 0,
    GateInfidelity = 1,
    T1Relaxation = 2,
    T2Dephasing = 3,
    Leakage = 4,
    Crosstalk = 5,
    Readout = 6,
    Idle = 7,
    Other = 8,
}
impl ErrorSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_SOURCE_UNSPECIFIED",
            Self::GateInfidelity => "ERROR_SOURCE_GATE_INFIDELITY",
            Self::T1Relaxation => "ERROR_SOURCE_T1_RELAXATION",
            Self::T2Dephasing => "ERROR_SOURCE_T2_DEPHASING",
            Self::Leakage => "ERROR_SOURCE_LEAKAGE",
            Self::Crosstalk => "ERROR_SOURCE_CROSSTALK",
            Self::Readout => "ERROR_SOURCE_READOUT",
            Self::Idle => "ERROR_SOURCE_IDLE",
            Self::Other => "ERROR_SOURCE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_SOURCE_GATE_INFIDELITY" => Some(Self::GateInfidelity),
            "ERROR_SOURCE_T1_RELAXATION" => Some(Self::T1Relaxation),
            "ERROR_SOURCE_T2_DEPHASING" => Some(Self::T2Dephasing),
            "ERROR_SOURCE_LEAKAGE" => Some(Self::Leakage),
            "ERROR_SOURCE_CROSSTALK" => Some(Self::Crosstalk),
            "ERROR_SOURCE_READOUT" => Some(Self::Readout),
            "ERROR_SOURCE_IDLE" => Some(Self::Idle),
            "ERROR_SOURCE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
