// This file is @generated by prost-build.
/// ExecutePulseRequest specifies a pulse execution job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutePulseRequest {
    /// Trace context for distributed tracing.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// Name of the backend to use.
    /// Values: "qutip_simulator", "iqm_garnet"
    #[prost(string, tag = "2")]
    pub backend_name: ::prost::alloc::string::String,
    /// The pulse to execute.
    #[prost(message, optional, tag = "3")]
    pub pulse: ::core::option::Option<super::super::pulse::v1::PulseShape>,
    /// Number of measurement shots.
    /// Each shot gives one bitstring outcome.
    /// Typical: 1000-10000
    /// Limit: 1,000,000 (enforced by server)
    #[prost(int32, tag = "4")]
    pub num_shots: i32,
    /// Measurement basis.
    /// Values: "z" (computational basis), "x", "y"
    /// Default: "z"
    #[prost(string, tag = "5")]
    pub measurement_basis: ::prost::alloc::string::String,
    /// Which qubits to measure.
    /// If empty, measures all qubits the pulse acts on.
    #[prost(int32, repeated, tag = "6")]
    pub measurement_qubits: ::prost::alloc::vec::Vec<i32>,
    /// Return the final state vector (simulator only).
    /// Useful for debugging but not available on real hardware.
    #[prost(bool, tag = "7")]
    pub return_state_vector: bool,
    /// Include calibrated noise model in simulation.
    /// If true, uses T1/T2/readout error from calibration.
    #[prost(bool, tag = "8")]
    pub include_noise: bool,
    /// Request timeout in milliseconds.
    /// 0 = use backend default.
    #[prost(int32, tag = "9")]
    pub timeout_ms: i32,
    /// Allow execution even if calibration fingerprint doesn't match.
    /// If true, executes with WARNING; if false, rejects with FAILED_PRECONDITION.
    #[prost(bool, tag = "10")]
    pub allow_calibration_mismatch: bool,
    /// Full pulse sequence with temporal constraints.
    /// If set, the server executes the sequence rather than a single pulse.
    #[prost(message, optional, tag = "11")]
    pub pulse_sequence: ::core::option::Option<super::super::pulse::v1::PulseSequence>,
}
/// ExecutePulseResponse contains the execution result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutePulseResponse {
    /// Trace context echoed back.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// Whether execution succeeded.
    #[prost(bool, tag = "2")]
    pub success: bool,
    /// Error details if success = false.
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::Error>,
    /// The measurement result.
    #[prost(message, optional, tag = "4")]
    pub result: ::core::option::Option<MeasurementResult>,
    /// Non-fatal warnings.
    #[prost(string, repeated, tag = "5")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MeasurementResult contains the outcome of pulse execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeasurementResult {
    /// Bitstring counts from measurement.
    /// Key: bitstring (e.g., "00", "01", "10", "11" for 2 qubits)
    /// Value: number of times this bitstring was observed
    /// Bitstring order: qubit 0 is rightmost (little-endian).
    #[prost(map = "string, int32", tag = "1")]
    pub bitstring_counts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    /// Total number of shots requested.
    #[prost(int32, tag = "2")]
    pub total_shots: i32,
    /// Number of shots that succeeded.
    /// May be less than total_shots if some failed.
    #[prost(int32, tag = "3")]
    pub successful_shots: i32,
    /// Quality indicator.
    #[prost(enumeration = "measurement_result::Quality", tag = "4")]
    pub quality: i32,
    /// Estimated gate fidelity from this measurement.
    /// Only meaningful for certain pulse types and measurement configurations.
    /// 0.0 if fidelity estimation is not applicable.
    #[prost(double, tag = "5")]
    pub fidelity_estimate: f64,
    /// Method used for fidelity estimation.
    /// Values: "direct_comparison", "state_tomography", "not_computed"
    #[prost(string, tag = "6")]
    pub fidelity_method: ::prost::alloc::string::String,
    /// Backend that executed this pulse.
    #[prost(string, tag = "7")]
    pub backend_name: ::prost::alloc::string::String,
    /// When measurement completed.
    #[prost(message, optional, tag = "8")]
    pub measured_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// Calibration fingerprint used.
    #[prost(string, tag = "9")]
    pub calibration_fingerprint: ::prost::alloc::string::String,
    /// Final state vector (if requested and available).
    #[prost(message, optional, tag = "10")]
    pub state_vector: ::core::option::Option<StateVector>,
    /// Noise parameters applied during simulation.
    #[prost(message, optional, tag = "11")]
    pub noise_applied: ::core::option::Option<NoiseParameters>,
    /// Execution timing statistics.
    #[prost(message, optional, tag = "12")]
    pub timing: ::core::option::Option<ExecutionTiming>,
    /// Predicted fidelity from error budget analysis (if computed).
    /// 0.0 if not computed.
    #[prost(double, tag = "13")]
    pub predicted_fidelity: f64,
    /// Full error budget analysis (if requested).
    #[prost(message, optional, tag = "14")]
    pub error_budget: ::core::option::Option<
        super::super::error::v1::ErrorBudgetSummary,
    >,
}
/// Nested message and enum types in `MeasurementResult`.
pub mod measurement_result {
    /// Quality indicator for the result.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Quality {
        Unspecified = 0,
        /// All shots completed successfully.
        FullSuccess = 1,
        /// Most shots succeeded but some failed.
        /// Result is usable but may have slightly higher noise.
        Degraded = 2,
        /// Significant number of shots failed.
        /// Result should be interpreted with caution.
        PartialFailure = 3,
        /// No usable data obtained.
        TotalFailure = 4,
    }
    impl Quality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "QUALITY_UNSPECIFIED",
                Self::FullSuccess => "QUALITY_FULL_SUCCESS",
                Self::Degraded => "QUALITY_DEGRADED",
                Self::PartialFailure => "QUALITY_PARTIAL_FAILURE",
                Self::TotalFailure => "QUALITY_TOTAL_FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "QUALITY_UNSPECIFIED" => Some(Self::Unspecified),
                "QUALITY_FULL_SUCCESS" => Some(Self::FullSuccess),
                "QUALITY_DEGRADED" => Some(Self::Degraded),
                "QUALITY_PARTIAL_FAILURE" => Some(Self::PartialFailure),
                "QUALITY_TOTAL_FAILURE" => Some(Self::TotalFailure),
                _ => None,
            }
        }
    }
}
/// StateVector represents the quantum state (simulator only).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateVector {
    /// Complex amplitudes as \[re_0, im_0, re_1, im_1, ...\].
    /// Length = 2 * 2^num_qubits
    #[prost(double, repeated, tag = "1")]
    pub amplitudes: ::prost::alloc::vec::Vec<f64>,
    /// Number of qubits.
    #[prost(int32, tag = "2")]
    pub num_qubits: i32,
}
/// NoiseParameters describes the noise model used.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoiseParameters {
    /// T1 relaxation time in microseconds.
    #[prost(double, tag = "1")]
    pub t1_us: f64,
    /// T2 dephasing time in microseconds.
    #[prost(double, tag = "2")]
    pub t2_us: f64,
    /// Readout error probability (average of 0->1 and 1->0 errors).
    #[prost(double, tag = "3")]
    pub readout_error: f64,
    /// Single-qubit gate error (from randomized benchmarking).
    #[prost(double, tag = "4")]
    pub single_gate_error: f64,
    /// Two-qubit gate error.
    #[prost(double, tag = "5")]
    pub two_gate_error: f64,
    /// Thermal equilibrium excited state population.
    #[prost(double, tag = "6")]
    pub thermal_population: f64,
}
/// ExecutionTiming provides timing breakdown.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecutionTiming {
    /// Time spent in queue (hardware backends).
    #[prost(int64, tag = "1")]
    pub queue_time_ms: i64,
    /// Time for actual pulse execution.
    #[prost(int64, tag = "2")]
    pub execution_time_ms: i64,
    /// Time for readout and processing.
    #[prost(int64, tag = "3")]
    pub readout_time_ms: i64,
    /// Total wall-clock time.
    #[prost(int64, tag = "4")]
    pub total_time_ms: i64,
}
/// ExecutePulseBatchRequest executes multiple pulses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutePulseBatchRequest {
    /// Trace context for the batch.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// Individual pulse requests.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<ExecutePulseRequest>,
    /// Stop batch on first error.
    /// If true, subsequent pulses are skipped after a failure.
    /// If false, all pulses are attempted regardless of earlier failures.
    #[prost(bool, tag = "3")]
    pub stop_on_first_error: bool,
}
/// ExecutePulseBatchResponse contains batch results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutePulseBatchResponse {
    /// Trace context echoed back.
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<super::super::common::v1::TraceContext>,
    /// Individual responses (same order as requests).
    #[prost(message, repeated, tag = "2")]
    pub responses: ::prost::alloc::vec::Vec<ExecutePulseResponse>,
    /// Count of successful executions.
    #[prost(int32, tag = "3")]
    pub successful_count: i32,
    /// Count of failed executions.
    #[prost(int32, tag = "4")]
    pub failed_count: i32,
    /// Count of skipped executions (if stop_on_first_error was true).
    #[prost(int32, tag = "5")]
    pub skipped_count: i32,
    /// Total batch execution time in milliseconds.
    #[prost(int64, tag = "6")]
    pub total_time_ms: i64,
}
/// GetHardwareInfoRequest requests information about a backend.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareInfoRequest {
    /// Backend name to query.
    #[prost(string, tag = "1")]
    pub backend_name: ::prost::alloc::string::String,
}
/// GetHardwareInfoResponse contains backend information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareInfoResponse {
    /// The hardware information.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<HardwareInfo>,
}
/// HardwareInfo describes a quantum backend's capabilities and status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareInfo {
    /// Backend identifier.
    #[prost(string, tag = "1")]
    pub backend_name: ::prost::alloc::string::String,
    /// Type of backend.
    /// Values: "simulator", "hardware"
    #[prost(string, tag = "2")]
    pub backend_type: ::prost::alloc::string::String,
    /// Deployment tier.
    /// Values: "local", "cloud", "on-premise"
    #[prost(string, tag = "3")]
    pub tier: ::prost::alloc::string::String,
    /// Number of qubits in the system.
    #[prost(int32, tag = "4")]
    pub num_qubits: i32,
    /// Indices of qubits available for use.
    /// May be a subset of 0..num_qubits-1 if some qubits are offline.
    #[prost(int32, repeated, tag = "5")]
    pub available_qubit_indices: ::prost::alloc::vec::Vec<i32>,
    /// Gates supported by this backend.
    #[prost(enumeration = "super::super::pulse::v1::GateType", repeated, tag = "6")]
    pub supported_gates: ::prost::alloc::vec::Vec<i32>,
    /// Pulse optimization algorithms supported.
    /// Values: "grape", "drag", "gaussian", "square"
    #[prost(string, repeated, tag = "7")]
    pub supported_algorithms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether state vector output is available.
    #[prost(bool, tag = "8")]
    pub supports_state_vector: bool,
    /// Whether noise modeling is available.
    #[prost(bool, tag = "9")]
    pub supports_noise_model: bool,
    /// Qubit pairs that support two-qubit gates.
    #[prost(message, repeated, tag = "10")]
    pub connectivity: ::prost::alloc::vec::Vec<QubitPair>,
    /// Performance characteristics.
    #[prost(message, optional, tag = "11")]
    pub performance: ::core::option::Option<PerformanceHints>,
    /// Resource limits.
    #[prost(message, optional, tag = "12")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// Whether this backend requires authentication.
    #[prost(bool, tag = "13")]
    pub requires_auth: bool,
    /// Software version of the backend.
    /// Example: "qutip-5.0.0" or "iqm-client-1.2.3"
    #[prost(string, tag = "14")]
    pub software_version: ::prost::alloc::string::String,
    /// Protocol version.
    #[prost(int32, tag = "15")]
    pub proto_version: i32,
    /// Current operational status.
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<OperationalStatus>,
    /// Validation status (cross-backend consistency).
    #[prost(message, optional, tag = "17")]
    pub validation: ::core::option::Option<ValidationStatus>,
}
/// QubitPair describes a connected pair of qubits.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QubitPair {
    /// First qubit index.
    #[prost(int32, tag = "1")]
    pub qubit_a: i32,
    /// Second qubit index.
    #[prost(int32, tag = "2")]
    pub qubit_b: i32,
    /// Two-qubit gates supported on this pair.
    #[prost(enumeration = "super::super::pulse::v1::GateType", repeated, tag = "3")]
    pub supported_gates: ::prost::alloc::vec::Vec<i32>,
    /// Coupling strength in kHz (if known).
    #[prost(double, tag = "4")]
    pub coupling_strength_khz: f64,
}
/// PerformanceHints provides latency and throughput information.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceHints {
    /// Median (P50) latency for single pulse execution in milliseconds.
    #[prost(double, tag = "1")]
    pub typical_latency_ms: f64,
    /// 95th percentile latency in milliseconds.
    #[prost(double, tag = "2")]
    pub p95_latency_ms: f64,
    /// 99th percentile latency in milliseconds.
    #[prost(double, tag = "3")]
    pub p99_latency_ms: f64,
    /// Maximum shots per individual request.
    #[prost(int32, tag = "4")]
    pub max_shots_per_request: i32,
    /// Recommended batch size for optimal throughput.
    #[prost(int32, tag = "5")]
    pub recommended_batch_size: i32,
    /// Maximum requests per second (rate limit).
    #[prost(double, tag = "6")]
    pub max_requests_per_second: f64,
    /// Default timeout in milliseconds.
    #[prost(int32, tag = "7")]
    pub default_timeout_ms: i32,
}
/// ResourceLimits specifies maximum allowed values.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// Maximum Hilbert space dimension.
    #[prost(int32, tag = "1")]
    pub max_hilbert_dim: i32,
    /// Maximum number of qubits.
    #[prost(int32, tag = "2")]
    pub max_qubits: i32,
    /// Maximum shots per request.
    #[prost(int32, tag = "3")]
    pub max_shots: i32,
    /// Maximum pulse duration in nanoseconds.
    #[prost(int32, tag = "4")]
    pub max_pulse_duration_ns: i32,
    /// Maximum number of time steps per pulse.
    #[prost(int32, tag = "5")]
    pub max_time_steps: i32,
    /// Maximum batch size.
    #[prost(int32, tag = "6")]
    pub max_batch_size: i32,
    /// Maximum concurrent requests.
    #[prost(int32, tag = "7")]
    pub max_concurrent_requests: i32,
    /// Maximum GRAPE iterations.
    #[prost(int32, tag = "8")]
    pub max_grape_iterations: i32,
}
/// OperationalStatus indicates current backend availability.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatus {
    /// Current status.
    #[prost(enumeration = "operational_status::Status", tag = "1")]
    pub status: i32,
    /// Human-readable status message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// When status was last updated.
    #[prost(message, optional, tag = "3")]
    pub updated_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// Expected time when backend will be back online (if offline/maintenance).
    #[prost(message, optional, tag = "4")]
    pub expected_recovery: ::core::option::Option<super::super::common::v1::Timestamp>,
}
/// Nested message and enum types in `OperationalStatus`.
pub mod operational_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Backend is fully operational.
        Online = 1,
        /// Backend is operational but with degraded performance.
        Degraded = 2,
        /// Backend is undergoing maintenance.
        Maintenance = 3,
        /// Backend is offline.
        Offline = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Online => "STATUS_ONLINE",
                Self::Degraded => "STATUS_DEGRADED",
                Self::Maintenance => "STATUS_MAINTENANCE",
                Self::Offline => "STATUS_OFFLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_ONLINE" => Some(Self::Online),
                "STATUS_DEGRADED" => Some(Self::Degraded),
                "STATUS_MAINTENANCE" => Some(Self::Maintenance),
                "STATUS_OFFLINE" => Some(Self::Offline),
                _ => None,
            }
        }
    }
}
/// ValidationStatus indicates cross-backend validation results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationStatus {
    /// Validation status.
    #[prost(enumeration = "validation_status::Status", tag = "1")]
    pub status: i32,
    /// Validation method used.
    /// Example: "hellinger_crosscheck_v1", "state_tomography_v1"
    #[prost(string, tag = "2")]
    pub method: ::prost::alloc::string::String,
    /// When validation was performed.
    #[prost(message, optional, tag = "3")]
    pub validated_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// Details about validation (pass/fail reasons).
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
    /// Validation metrics (e.g., Hellinger distance).
    #[prost(map = "string, double", tag = "5")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
}
/// Nested message and enum types in `ValidationStatus`.
pub mod validation_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Backend passed validation.
        Passed = 1,
        /// Backend failed validation.
        Failed = 2,
        /// Validation results have expired.
        Expired = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Passed => "STATUS_PASSED",
                Self::Failed => "STATUS_FAILED",
                Self::Expired => "STATUS_EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_PASSED" => Some(Self::Passed),
                "STATUS_FAILED" => Some(Self::Failed),
                "STATUS_EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// HealthRequest checks backend health.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthRequest {
    /// Backend to check.
    /// If empty, checks all backends.
    #[prost(string, tag = "1")]
    pub backend_name: ::prost::alloc::string::String,
}
/// HealthResponse contains health check results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    /// Overall status (worst status if multiple backends checked).
    #[prost(enumeration = "health_response::Status", tag = "1")]
    pub status: i32,
    /// Human-readable message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// When health check was performed.
    #[prost(message, optional, tag = "3")]
    pub checked_at: ::core::option::Option<super::super::common::v1::Timestamp>,
    /// Latency of health check in milliseconds.
    #[prost(double, tag = "4")]
    pub latency_ms: f64,
    /// Per-backend status (if backend_name was empty).
    #[prost(map = "string, enumeration(health_response::Status)", tag = "5")]
    pub backend_statuses: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    /// Per-backend details.
    #[prost(map = "string, string", tag = "6")]
    pub backend_messages: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `HealthResponse`.
pub mod health_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Backend is healthy and accepting requests.
        Healthy = 1,
        /// Backend is operational but with issues.
        Degraded = 2,
        /// Backend is not accepting requests.
        Unavailable = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Healthy => "STATUS_HEALTHY",
                Self::Degraded => "STATUS_DEGRADED",
                Self::Unavailable => "STATUS_UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_HEALTHY" => Some(Self::Healthy),
                "STATUS_DEGRADED" => Some(Self::Degraded),
                "STATUS_UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
/// ListBackendsRequest requests a list of all available backends.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListBackendsRequest {
    /// If true, include detailed info for each backend.
    /// If false, return names only (faster).
    #[prost(bool, tag = "1")]
    pub include_details: bool,
}
/// ListBackendsResponse contains available backends.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendsResponse {
    /// Backend names.
    #[prost(string, repeated, tag = "1")]
    pub backend_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Detailed info if requested.
    #[prost(message, repeated, tag = "2")]
    pub backends: ::prost::alloc::vec::Vec<HardwareInfo>,
}
/// Generated client implementations.
pub mod quantum_backend_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// QuantumBackendService provides access to quantum hardware and simulators.
    ///
    /// This is the primary interface for executing pulses and querying backend
    /// capabilities. All pulse execution flows through this service.
    ///
    /// Supported backends:
    /// - qutip_simulator: Local QuTiP-based simulator (always available)
    /// - iqm_garnet: IQM Garnet quantum processor (requires credentials)
    #[derive(Debug, Clone)]
    pub struct QuantumBackendServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QuantumBackendServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QuantumBackendServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QuantumBackendServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QuantumBackendServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Execute a single pulse on the specified backend.
        ///
        /// The pulse is validated before execution. If validation fails,
        /// returns INVALID_ARGUMENT error.
        ///
        /// For simulators: returns measurement samples from the final state.
        /// For hardware: submits to queue and returns when complete.
        pub async fn execute_pulse(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecutePulseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutePulseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.backend.v1.QuantumBackendService/ExecutePulse",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "quantum.backend.v1.QuantumBackendService",
                        "ExecutePulse",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Execute multiple pulses in a batch.
        ///
        /// More efficient than individual calls when running many pulses.
        /// Can optionally stop on first error or continue despite failures.
        pub async fn execute_pulse_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecutePulseBatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutePulseBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.backend.v1.QuantumBackendService/ExecutePulseBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "quantum.backend.v1.QuantumBackendService",
                        "ExecutePulseBatch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get detailed information about a backend.
        ///
        /// Returns capabilities, resource limits, connectivity, and current status.
        pub async fn get_hardware_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetHardwareInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.backend.v1.QuantumBackendService/GetHardwareInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "quantum.backend.v1.QuantumBackendService",
                        "GetHardwareInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Check health of a specific backend or all backends.
        ///
        /// Use for monitoring and to check availability before submitting jobs.
        pub async fn health(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.backend.v1.QuantumBackendService/Health",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("quantum.backend.v1.QuantumBackendService", "Health"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all available backends.
        pub async fn list_backends(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackendsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackendsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/quantum.backend.v1.QuantumBackendService/ListBackends",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "quantum.backend.v1.QuantumBackendService",
                        "ListBackends",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod quantum_backend_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QuantumBackendServiceServer.
    #[async_trait]
    pub trait QuantumBackendService: std::marker::Send + std::marker::Sync + 'static {
        /// Execute a single pulse on the specified backend.
        ///
        /// The pulse is validated before execution. If validation fails,
        /// returns INVALID_ARGUMENT error.
        ///
        /// For simulators: returns measurement samples from the final state.
        /// For hardware: submits to queue and returns when complete.
        async fn execute_pulse(
            &self,
            request: tonic::Request<super::ExecutePulseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutePulseResponse>,
            tonic::Status,
        >;
        /// Execute multiple pulses in a batch.
        ///
        /// More efficient than individual calls when running many pulses.
        /// Can optionally stop on first error or continue despite failures.
        async fn execute_pulse_batch(
            &self,
            request: tonic::Request<super::ExecutePulseBatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecutePulseBatchResponse>,
            tonic::Status,
        >;
        /// Get detailed information about a backend.
        ///
        /// Returns capabilities, resource limits, connectivity, and current status.
        async fn get_hardware_info(
            &self,
            request: tonic::Request<super::GetHardwareInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetHardwareInfoResponse>,
            tonic::Status,
        >;
        /// Check health of a specific backend or all backends.
        ///
        /// Use for monitoring and to check availability before submitting jobs.
        async fn health(
            &self,
            request: tonic::Request<super::HealthRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status>;
        /// List all available backends.
        async fn list_backends(
            &self,
            request: tonic::Request<super::ListBackendsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackendsResponse>,
            tonic::Status,
        >;
    }
    /// QuantumBackendService provides access to quantum hardware and simulators.
    ///
    /// This is the primary interface for executing pulses and querying backend
    /// capabilities. All pulse execution flows through this service.
    ///
    /// Supported backends:
    /// - qutip_simulator: Local QuTiP-based simulator (always available)
    /// - iqm_garnet: IQM Garnet quantum processor (requires credentials)
    #[derive(Debug)]
    pub struct QuantumBackendServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> QuantumBackendServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for QuantumBackendServiceServer<T>
    where
        T: QuantumBackendService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/quantum.backend.v1.QuantumBackendService/ExecutePulse" => {
                    #[allow(non_camel_case_types)]
                    struct ExecutePulseSvc<T: QuantumBackendService>(pub Arc<T>);
                    impl<
                        T: QuantumBackendService,
                    > tonic::server::UnaryService<super::ExecutePulseRequest>
                    for ExecutePulseSvc<T> {
                        type Response = super::ExecutePulseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecutePulseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QuantumBackendService>::execute_pulse(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecutePulseSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/quantum.backend.v1.QuantumBackendService/ExecutePulseBatch" => {
                    #[allow(non_camel_case_types)]
                    struct ExecutePulseBatchSvc<T: QuantumBackendService>(pub Arc<T>);
                    impl<
                        T: QuantumBackendService,
                    > tonic::server::UnaryService<super::ExecutePulseBatchRequest>
                    for ExecutePulseBatchSvc<T> {
                        type Response = super::ExecutePulseBatchResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecutePulseBatchRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QuantumBackendService>::execute_pulse_batch(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecutePulseBatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/quantum.backend.v1.QuantumBackendService/GetHardwareInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetHardwareInfoSvc<T: QuantumBackendService>(pub Arc<T>);
                    impl<
                        T: QuantumBackendService,
                    > tonic::server::UnaryService<super::GetHardwareInfoRequest>
                    for GetHardwareInfoSvc<T> {
                        type Response = super::GetHardwareInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetHardwareInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QuantumBackendService>::get_hardware_info(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHardwareInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/quantum.backend.v1.QuantumBackendService/Health" => {
                    #[allow(non_camel_case_types)]
                    struct HealthSvc<T: QuantumBackendService>(pub Arc<T>);
                    impl<
                        T: QuantumBackendService,
                    > tonic::server::UnaryService<super::HealthRequest>
                    for HealthSvc<T> {
                        type Response = super::HealthResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HealthRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QuantumBackendService>::health(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HealthSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/quantum.backend.v1.QuantumBackendService/ListBackends" => {
                    #[allow(non_camel_case_types)]
                    struct ListBackendsSvc<T: QuantumBackendService>(pub Arc<T>);
                    impl<
                        T: QuantumBackendService,
                    > tonic::server::UnaryService<super::ListBackendsRequest>
                    for ListBackendsSvc<T> {
                        type Response = super::ListBackendsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBackendsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as QuantumBackendService>::list_backends(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBackendsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for QuantumBackendServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "quantum.backend.v1.QuantumBackendService";
    impl<T> tonic::server::NamedService for QuantumBackendServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
