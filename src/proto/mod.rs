// Copyright 2026 QubitOS Contributors
// SPDX-License-Identifier: Apache-2.0

//! Generated Protocol Buffer types.
//!
//! This module contains Rust types for the QubitOS Protocol Buffer definitions.
//! When protoc is available, these are generated by tonic-build during compilation.
//! Otherwise, stub types are provided for compilation to succeed.

// Stub types for when protos aren't generated
// This allows the code to compile without protoc

pub mod quantum {
    pub mod common {
        pub mod v1 {
            use serde::{Deserialize, Serialize};

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct TraceContext {
                pub trace_id: String,
                pub span_id: String,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct Timestamp {
                pub seconds: i64,
                pub nanos: i32,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct Error {
                pub code: String,
                pub message: String,
            }
        }
    }

    pub mod pulse {
        pub mod v1 {
            use serde::{Deserialize, Serialize};

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct HamiltonianSpec {
                pub drift_terms: Vec<PauliTerm>,
                pub control_terms: Vec<ControlTerm>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct PauliTerm {
                pub coefficient: f64,
                pub paulis: String,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct ControlTerm {
                pub name: String,
                pub paulis: String,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct PulseShape {
                pub pulse_id: String,
                pub i_envelope: Vec<f64>,
                pub q_envelope: Vec<f64>,
                pub duration_ns: u32,
                pub num_time_steps: u32,
            }

            #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
            #[repr(i32)]
            pub enum GateType {
                #[default]
                Unspecified = 0,
                X = 1,
                Y = 2,
                Z = 3,
                H = 4,
                Sx = 5,
                Cz = 6,
                Cnot = 7,
                Iswap = 8,
            }
        }
    }

    pub mod backend {
        pub mod v1 {
            use serde::{Deserialize, Serialize};
            use std::collections::HashMap;

            // Service trait for gRPC
            pub mod quantum_backend_server {
                use super::*;
                use tonic::{Request, Response, Status};

                /// Service name for gRPC reflection
                pub const SERVICE_NAME: &str = "quantum.backend.v1.QuantumBackend";

                #[tonic::async_trait]
                pub trait QuantumBackend: Send + Sync + 'static {
                    async fn execute_pulse(
                        &self,
                        request: Request<ExecutePulseRequest>,
                    ) -> Result<Response<ExecutePulseResponse>, Status>;

                    async fn get_hardware_info(
                        &self,
                        request: Request<GetHardwareInfoRequest>,
                    ) -> Result<Response<GetHardwareInfoResponse>, Status>;

                    async fn health_check(
                        &self,
                        request: Request<HealthCheckRequest>,
                    ) -> Result<Response<HealthCheckResponse>, Status>;
                }

                #[derive(Debug, Clone)]
                #[allow(dead_code)]
                pub struct QuantumBackendServer<T> {
                    inner: std::sync::Arc<T>,
                }

                impl<T: QuantumBackend> QuantumBackendServer<T> {
                    pub fn new(inner: T) -> Self {
                        Self {
                            inner: std::sync::Arc::new(inner),
                        }
                    }
                }

                impl<T: QuantumBackend> tonic::server::NamedService for QuantumBackendServer<T> {
                    const NAME: &'static str = SERVICE_NAME;
                }

                // Use http::Request<tonic::body::BoxBody> as the correct type for tonic 0.12
                impl<T: QuantumBackend> tower::Service<http::Request<tonic::body::BoxBody>>
                    for QuantumBackendServer<T>
                {
                    type Response = http::Response<tonic::body::BoxBody>;
                    type Error = std::convert::Infallible;
                    type Future = std::pin::Pin<
                        Box<
                            dyn std::future::Future<Output = Result<Self::Response, Self::Error>>
                                + Send
                                + 'static,
                        >,
                    >;

                    fn poll_ready(
                        &mut self,
                        _cx: &mut std::task::Context<'_>,
                    ) -> std::task::Poll<Result<(), Self::Error>> {
                        std::task::Poll::Ready(Ok(()))
                    }

                    fn call(&mut self, _req: http::Request<tonic::body::BoxBody>) -> Self::Future {
                        Box::pin(async move {
                            Ok(http::Response::builder()
                                .status(501)
                                .body(tonic::body::empty_body())
                                .unwrap())
                        })
                    }
                }
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct ExecutePulseRequest {
                pub pulse_id: String,
                pub backend_name: Option<String>,
                pub i_envelope: Vec<f64>,
                pub q_envelope: Vec<f64>,
                pub duration_ns: u32,
                pub num_time_steps: u32,
                pub target_qubits: Vec<u32>,
                pub num_shots: u32,
                pub measurement_basis: String,
                pub return_state_vector: bool,
                pub include_noise: bool,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct ExecutePulseResponse {
                pub request_id: String,
                pub pulse_id: String,
                pub result: Option<MeasurementResult>,
                pub error: Option<super::super::common::v1::Error>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct MeasurementResult {
                pub bitstring_counts: Option<BitstringCounts>,
                pub total_shots: u32,
                pub successful_shots: u32,
                pub fidelity_estimate: Option<f64>,
                pub state_vector_real: Vec<f64>,
                pub state_vector_imag: Vec<f64>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct BitstringCounts {
                pub counts: HashMap<String, i64>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct GetHardwareInfoRequest {
                pub backend_name: Option<String>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct GetHardwareInfoResponse {
                pub info: Option<HardwareInfo>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct HardwareInfo {
                pub name: String,
                pub backend_type: i32,
                pub tier: String,
                pub num_qubits: u32,
                pub available_qubits: Vec<u32>,
                pub supported_gates: Vec<String>,
                pub supports_state_vector: bool,
                pub supports_noise_model: bool,
                pub software_version: String,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct HealthCheckRequest {
                pub backend_name: Option<String>,
            }

            #[derive(Clone, Debug, Default, Serialize, Deserialize)]
            pub struct HealthCheckResponse {
                pub status: i32,
                pub message: String,
                pub backends: HashMap<String, i32>,
            }

            #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
            #[repr(i32)]
            pub enum HealthStatus {
                #[default]
                Unknown = 0,
                Healthy = 1,
                Degraded = 2,
                Unavailable = 3,
            }
        }
    }
}

// Re-exports for convenience
pub use quantum::backend::v1::*;
pub use quantum::common::v1 as common;
pub use quantum::pulse::v1 as pulse;
